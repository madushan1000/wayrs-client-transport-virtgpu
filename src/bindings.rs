/* automatically generated by rust-bindgen 0.68.1 */

pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const DRM_NAME: &[u8; 4] = b"drm\0";
pub const DRM_MIN_ORDER: u32 = 5;
pub const DRM_MAX_ORDER: u32 = 22;
pub const DRM_RAM_PERCENT: u32 = 10;
pub const _DRM_LOCK_HELD: u32 = 2147483648;
pub const _DRM_LOCK_CONT: u32 = 1073741824;
pub const _DRM_VBLANK_HIGH_CRTC_SHIFT: u32 = 1;
pub const _DRM_PRE_MODESET: u32 = 1;
pub const _DRM_POST_MODESET: u32 = 2;
pub const DRM_CAP_DUMB_BUFFER: u32 = 1;
pub const DRM_CAP_VBLANK_HIGH_CRTC: u32 = 2;
pub const DRM_CAP_DUMB_PREFERRED_DEPTH: u32 = 3;
pub const DRM_CAP_DUMB_PREFER_SHADOW: u32 = 4;
pub const DRM_CAP_PRIME: u32 = 5;
pub const DRM_PRIME_CAP_IMPORT: u32 = 1;
pub const DRM_PRIME_CAP_EXPORT: u32 = 2;
pub const DRM_CAP_TIMESTAMP_MONOTONIC: u32 = 6;
pub const DRM_CAP_ASYNC_PAGE_FLIP: u32 = 7;
pub const DRM_CAP_CURSOR_WIDTH: u32 = 8;
pub const DRM_CAP_CURSOR_HEIGHT: u32 = 9;
pub const DRM_CAP_ADDFB2_MODIFIERS: u32 = 16;
pub const DRM_CAP_PAGE_FLIP_TARGET: u32 = 17;
pub const DRM_CAP_CRTC_IN_VBLANK_EVENT: u32 = 18;
pub const DRM_CAP_SYNCOBJ: u32 = 19;
pub const DRM_CAP_SYNCOBJ_TIMELINE: u32 = 20;
pub const DRM_CAP_ATOMIC_ASYNC_PAGE_FLIP: u32 = 21;
pub const DRM_CLIENT_CAP_STEREO_3D: u32 = 1;
pub const DRM_CLIENT_CAP_UNIVERSAL_PLANES: u32 = 2;
pub const DRM_CLIENT_CAP_ATOMIC: u32 = 3;
pub const DRM_CLIENT_CAP_ASPECT_RATIO: u32 = 4;
pub const DRM_CLIENT_CAP_WRITEBACK_CONNECTORS: u32 = 5;
pub const DRM_CLIENT_CAP_CURSOR_PLANE_HOTSPOT: u32 = 6;
pub const DRM_SYNCOBJ_CREATE_SIGNALED: u32 = 1;
pub const DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE: u32 = 1;
pub const DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_EXPORT_SYNC_FILE: u32 = 1;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL: u32 = 1;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT: u32 = 2;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE: u32 = 4;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_DEADLINE: u32 = 8;
pub const DRM_SYNCOBJ_QUERY_FLAGS_LAST_SUBMITTED: u32 = 1;
pub const DRM_CRTC_SEQUENCE_RELATIVE: u32 = 1;
pub const DRM_CRTC_SEQUENCE_NEXT_ON_MISS: u32 = 2;
pub const DRM_CONNECTOR_NAME_LEN: u32 = 32;
pub const DRM_DISPLAY_MODE_LEN: u32 = 32;
pub const DRM_PROP_NAME_LEN: u32 = 32;
pub const DRM_MODE_TYPE_BUILTIN: u32 = 1;
pub const DRM_MODE_TYPE_CLOCK_C: u32 = 3;
pub const DRM_MODE_TYPE_CRTC_C: u32 = 5;
pub const DRM_MODE_TYPE_PREFERRED: u32 = 8;
pub const DRM_MODE_TYPE_DEFAULT: u32 = 16;
pub const DRM_MODE_TYPE_USERDEF: u32 = 32;
pub const DRM_MODE_TYPE_DRIVER: u32 = 64;
pub const DRM_MODE_TYPE_ALL: u32 = 104;
pub const DRM_MODE_FLAG_PHSYNC: u32 = 1;
pub const DRM_MODE_FLAG_NHSYNC: u32 = 2;
pub const DRM_MODE_FLAG_PVSYNC: u32 = 4;
pub const DRM_MODE_FLAG_NVSYNC: u32 = 8;
pub const DRM_MODE_FLAG_INTERLACE: u32 = 16;
pub const DRM_MODE_FLAG_DBLSCAN: u32 = 32;
pub const DRM_MODE_FLAG_CSYNC: u32 = 64;
pub const DRM_MODE_FLAG_PCSYNC: u32 = 128;
pub const DRM_MODE_FLAG_NCSYNC: u32 = 256;
pub const DRM_MODE_FLAG_HSKEW: u32 = 512;
pub const DRM_MODE_FLAG_BCAST: u32 = 1024;
pub const DRM_MODE_FLAG_PIXMUX: u32 = 2048;
pub const DRM_MODE_FLAG_DBLCLK: u32 = 4096;
pub const DRM_MODE_FLAG_CLKDIV2: u32 = 8192;
pub const DRM_MODE_FLAG_3D_MASK: u32 = 507904;
pub const DRM_MODE_FLAG_3D_NONE: u32 = 0;
pub const DRM_MODE_FLAG_3D_FRAME_PACKING: u32 = 16384;
pub const DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: u32 = 32768;
pub const DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: u32 = 49152;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: u32 = 65536;
pub const DRM_MODE_FLAG_3D_L_DEPTH: u32 = 81920;
pub const DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: u32 = 98304;
pub const DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: u32 = 114688;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: u32 = 131072;
pub const DRM_MODE_PICTURE_ASPECT_NONE: u32 = 0;
pub const DRM_MODE_PICTURE_ASPECT_4_3: u32 = 1;
pub const DRM_MODE_PICTURE_ASPECT_16_9: u32 = 2;
pub const DRM_MODE_PICTURE_ASPECT_64_27: u32 = 3;
pub const DRM_MODE_PICTURE_ASPECT_256_135: u32 = 4;
pub const DRM_MODE_CONTENT_TYPE_NO_DATA: u32 = 0;
pub const DRM_MODE_CONTENT_TYPE_GRAPHICS: u32 = 1;
pub const DRM_MODE_CONTENT_TYPE_PHOTO: u32 = 2;
pub const DRM_MODE_CONTENT_TYPE_CINEMA: u32 = 3;
pub const DRM_MODE_CONTENT_TYPE_GAME: u32 = 4;
pub const DRM_MODE_FLAG_PIC_AR_MASK: u32 = 7864320;
pub const DRM_MODE_FLAG_PIC_AR_NONE: u32 = 0;
pub const DRM_MODE_FLAG_PIC_AR_4_3: u32 = 524288;
pub const DRM_MODE_FLAG_PIC_AR_16_9: u32 = 1048576;
pub const DRM_MODE_FLAG_PIC_AR_64_27: u32 = 1572864;
pub const DRM_MODE_FLAG_PIC_AR_256_135: u32 = 2097152;
pub const DRM_MODE_FLAG_ALL: u32 = 521215;
pub const DRM_MODE_DPMS_ON: u32 = 0;
pub const DRM_MODE_DPMS_STANDBY: u32 = 1;
pub const DRM_MODE_DPMS_SUSPEND: u32 = 2;
pub const DRM_MODE_DPMS_OFF: u32 = 3;
pub const DRM_MODE_SCALE_NONE: u32 = 0;
pub const DRM_MODE_SCALE_FULLSCREEN: u32 = 1;
pub const DRM_MODE_SCALE_CENTER: u32 = 2;
pub const DRM_MODE_SCALE_ASPECT: u32 = 3;
pub const DRM_MODE_DITHERING_OFF: u32 = 0;
pub const DRM_MODE_DITHERING_ON: u32 = 1;
pub const DRM_MODE_DITHERING_AUTO: u32 = 2;
pub const DRM_MODE_DIRTY_OFF: u32 = 0;
pub const DRM_MODE_DIRTY_ON: u32 = 1;
pub const DRM_MODE_DIRTY_ANNOTATE: u32 = 2;
pub const DRM_MODE_LINK_STATUS_GOOD: u32 = 0;
pub const DRM_MODE_LINK_STATUS_BAD: u32 = 1;
pub const DRM_MODE_ROTATE_0: u32 = 1;
pub const DRM_MODE_ROTATE_90: u32 = 2;
pub const DRM_MODE_ROTATE_180: u32 = 4;
pub const DRM_MODE_ROTATE_270: u32 = 8;
pub const DRM_MODE_ROTATE_MASK: u32 = 15;
pub const DRM_MODE_REFLECT_X: u32 = 16;
pub const DRM_MODE_REFLECT_Y: u32 = 32;
pub const DRM_MODE_REFLECT_MASK: u32 = 48;
pub const DRM_MODE_CONTENT_PROTECTION_UNDESIRED: u32 = 0;
pub const DRM_MODE_CONTENT_PROTECTION_DESIRED: u32 = 1;
pub const DRM_MODE_CONTENT_PROTECTION_ENABLED: u32 = 2;
pub const DRM_MODE_PRESENT_TOP_FIELD: u32 = 1;
pub const DRM_MODE_PRESENT_BOTTOM_FIELD: u32 = 2;
pub const DRM_MODE_ENCODER_NONE: u32 = 0;
pub const DRM_MODE_ENCODER_DAC: u32 = 1;
pub const DRM_MODE_ENCODER_TMDS: u32 = 2;
pub const DRM_MODE_ENCODER_LVDS: u32 = 3;
pub const DRM_MODE_ENCODER_TVDAC: u32 = 4;
pub const DRM_MODE_ENCODER_VIRTUAL: u32 = 5;
pub const DRM_MODE_ENCODER_DSI: u32 = 6;
pub const DRM_MODE_ENCODER_DPMST: u32 = 7;
pub const DRM_MODE_ENCODER_DPI: u32 = 8;
pub const DRM_MODE_CONNECTOR_Unknown: u32 = 0;
pub const DRM_MODE_CONNECTOR_VGA: u32 = 1;
pub const DRM_MODE_CONNECTOR_DVII: u32 = 2;
pub const DRM_MODE_CONNECTOR_DVID: u32 = 3;
pub const DRM_MODE_CONNECTOR_DVIA: u32 = 4;
pub const DRM_MODE_CONNECTOR_Composite: u32 = 5;
pub const DRM_MODE_CONNECTOR_SVIDEO: u32 = 6;
pub const DRM_MODE_CONNECTOR_LVDS: u32 = 7;
pub const DRM_MODE_CONNECTOR_Component: u32 = 8;
pub const DRM_MODE_CONNECTOR_9PinDIN: u32 = 9;
pub const DRM_MODE_CONNECTOR_DisplayPort: u32 = 10;
pub const DRM_MODE_CONNECTOR_HDMIA: u32 = 11;
pub const DRM_MODE_CONNECTOR_HDMIB: u32 = 12;
pub const DRM_MODE_CONNECTOR_TV: u32 = 13;
pub const DRM_MODE_CONNECTOR_eDP: u32 = 14;
pub const DRM_MODE_CONNECTOR_VIRTUAL: u32 = 15;
pub const DRM_MODE_CONNECTOR_DSI: u32 = 16;
pub const DRM_MODE_CONNECTOR_DPI: u32 = 17;
pub const DRM_MODE_CONNECTOR_WRITEBACK: u32 = 18;
pub const DRM_MODE_CONNECTOR_SPI: u32 = 19;
pub const DRM_MODE_CONNECTOR_USB: u32 = 20;
pub const DRM_MODE_PROP_PENDING: u32 = 1;
pub const DRM_MODE_PROP_RANGE: u32 = 2;
pub const DRM_MODE_PROP_IMMUTABLE: u32 = 4;
pub const DRM_MODE_PROP_ENUM: u32 = 8;
pub const DRM_MODE_PROP_BLOB: u32 = 16;
pub const DRM_MODE_PROP_BITMASK: u32 = 32;
pub const DRM_MODE_PROP_LEGACY_TYPE: u32 = 58;
pub const DRM_MODE_PROP_EXTENDED_TYPE: u32 = 65472;
pub const DRM_MODE_PROP_ATOMIC: u32 = 2147483648;
pub const DRM_MODE_OBJECT_CRTC: u32 = 3435973836;
pub const DRM_MODE_OBJECT_CONNECTOR: u32 = 3233857728;
pub const DRM_MODE_OBJECT_ENCODER: u32 = 3772834016;
pub const DRM_MODE_OBJECT_MODE: u32 = 3739147998;
pub const DRM_MODE_OBJECT_PROPERTY: u32 = 2964369584;
pub const DRM_MODE_OBJECT_FB: u32 = 4227595259;
pub const DRM_MODE_OBJECT_BLOB: u32 = 3149642683;
pub const DRM_MODE_OBJECT_PLANE: u32 = 4008636142;
pub const DRM_MODE_OBJECT_ANY: u32 = 0;
pub const DRM_MODE_FB_INTERLACED: u32 = 1;
pub const DRM_MODE_FB_MODIFIERS: u32 = 2;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_COPY: u32 = 1;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_FILL: u32 = 2;
pub const DRM_MODE_FB_DIRTY_FLAGS: u32 = 3;
pub const DRM_MODE_FB_DIRTY_MAX_CLIPS: u32 = 256;
pub const DRM_MODE_CURSOR_BO: u32 = 1;
pub const DRM_MODE_CURSOR_MOVE: u32 = 2;
pub const DRM_MODE_CURSOR_FLAGS: u32 = 3;
pub const DRM_MODE_PAGE_FLIP_EVENT: u32 = 1;
pub const DRM_MODE_PAGE_FLIP_ASYNC: u32 = 2;
pub const DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE: u32 = 4;
pub const DRM_MODE_PAGE_FLIP_TARGET_RELATIVE: u32 = 8;
pub const DRM_MODE_PAGE_FLIP_TARGET: u32 = 12;
pub const DRM_MODE_PAGE_FLIP_FLAGS: u32 = 15;
pub const DRM_MODE_ATOMIC_TEST_ONLY: u32 = 256;
pub const DRM_MODE_ATOMIC_NONBLOCK: u32 = 512;
pub const DRM_MODE_ATOMIC_ALLOW_MODESET: u32 = 1024;
pub const DRM_MODE_ATOMIC_FLAGS: u32 = 1795;
pub const FORMAT_BLOB_CURRENT: u32 = 1;
pub const DRM_IOCTL_BASE: u8 = 100u8;
pub const DRM_COMMAND_BASE: u32 = 64;
pub const DRM_COMMAND_END: u32 = 160;
pub const DRM_EVENT_VBLANK: u32 = 1;
pub const DRM_EVENT_FLIP_COMPLETE: u32 = 2;
pub const DRM_EVENT_CRTC_SEQUENCE: u32 = 3;
pub const DRM_VIRTGPU_MAP: u32 = 1;
pub const DRM_VIRTGPU_EXECBUFFER: u32 = 2;
pub const DRM_VIRTGPU_GETPARAM: u32 = 3;
pub const DRM_VIRTGPU_RESOURCE_CREATE: u32 = 4;
pub const DRM_VIRTGPU_RESOURCE_INFO: u32 = 5;
pub const DRM_VIRTGPU_TRANSFER_FROM_HOST: u32 = 6;
pub const DRM_VIRTGPU_TRANSFER_TO_HOST: u32 = 7;
pub const DRM_VIRTGPU_WAIT: u32 = 8;
pub const DRM_VIRTGPU_GET_CAPS: u32 = 9;
pub const DRM_VIRTGPU_RESOURCE_CREATE_BLOB: u32 = 10;
pub const DRM_VIRTGPU_CONTEXT_INIT: u32 = 11;
pub const VIRTGPU_EXECBUF_FENCE_FD_IN: u32 = 1;
pub const VIRTGPU_EXECBUF_FENCE_FD_OUT: u32 = 2;
pub const VIRTGPU_EXECBUF_RING_IDX: u32 = 4;
pub const VIRTGPU_EXECBUF_FLAGS: u32 = 7;
pub const VIRTGPU_EXECBUF_SYNCOBJ_RESET: u32 = 1;
pub const VIRTGPU_EXECBUF_SYNCOBJ_FLAGS: u32 = 1;
pub const VIRTGPU_PARAM_3D_FEATURES: u32 = 1;
pub const VIRTGPU_PARAM_CAPSET_QUERY_FIX: u32 = 2;
pub const VIRTGPU_PARAM_RESOURCE_BLOB: u32 = 3;
pub const VIRTGPU_PARAM_HOST_VISIBLE: u32 = 4;
pub const VIRTGPU_PARAM_CROSS_DEVICE: u32 = 5;
pub const VIRTGPU_PARAM_CONTEXT_INIT: u32 = 6;
pub const VIRTGPU_PARAM_SUPPORTED_CAPSET_IDs: u32 = 7;
pub const VIRTGPU_PARAM_EXPLICIT_DEBUG_NAME: u32 = 8;
pub const VIRTGPU_WAIT_NOWAIT: u32 = 1;
pub const VIRTGPU_BLOB_MEM_GUEST: u32 = 1;
pub const VIRTGPU_BLOB_MEM_HOST3D: u32 = 2;
pub const VIRTGPU_BLOB_MEM_HOST3D_GUEST: u32 = 3;
pub const VIRTGPU_BLOB_FLAG_USE_MAPPABLE: u32 = 1;
pub const VIRTGPU_BLOB_FLAG_USE_SHAREABLE: u32 = 2;
pub const VIRTGPU_BLOB_FLAG_USE_CROSS_DEVICE: u32 = 4;
pub const VIRTGPU_CONTEXT_PARAM_CAPSET_ID: u32 = 1;
pub const VIRTGPU_CONTEXT_PARAM_NUM_RINGS: u32 = 2;
pub const VIRTGPU_CONTEXT_PARAM_POLL_RINGS_MASK: u32 = 3;
pub const VIRTGPU_CONTEXT_PARAM_DEBUG_NAME: u32 = 4;
pub const VIRTGPU_EVENT_FENCE_SIGNALED: u32 = 2415919104;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const CROSS_DOMAIN_CMD_INIT: u32 = 1;
pub const CROSS_DOMAIN_CMD_GET_IMAGE_REQUIREMENTS: u32 = 2;
pub const CROSS_DOMAIN_CMD_POLL: u32 = 3;
pub const CROSS_DOMAIN_CMD_SEND: u32 = 4;
pub const CROSS_DOMAIN_CMD_RECEIVE: u32 = 5;
pub const CROSS_DOMAIN_CMD_READ: u32 = 6;
pub const CROSS_DOMAIN_CMD_WRITE: u32 = 7;
pub const CROSS_DOMAIN_CHANNEL_TYPE_WAYLAND: u32 = 1;
pub const CROSS_DOMAIN_CHANNEL_TYPE_CAMERA: u32 = 2;
pub const CROSS_DOMAIN_MAX_IDENTIFIERS: u32 = 28;
pub const CROSS_DOMAIN_ID_TYPE_VIRTGPU_BLOB: u32 = 1;
pub const CROSS_DOMAIN_ID_TYPE_VIRTGPU_SYNC: u32 = 2;
pub const CROSS_DOMAIN_ID_TYPE_READ_PIPE: u32 = 3;
pub const CROSS_DOMAIN_ID_TYPE_WRITE_PIPE: u32 = 4;
pub const CROSS_DOMAIN_RING_NONE: u32 = 4294967295;
pub const CROSS_DOMAIN_QUERY_RING: u32 = 0;
pub const CROSS_DOMAIN_CHANNEL_RING: u32 = 1;
pub const CROSS_DOMAIN_PIPE_READ_START: u32 = 2147483648;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __s128 = i128;
pub type __u128 = u128;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub type drm_handle_t = ::std::os::raw::c_uint;
pub type drm_context_t = ::std::os::raw::c_uint;
pub type drm_drawable_t = ::std::os::raw::c_uint;
pub type drm_magic_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_clip_rect {
    pub x1: ::std::os::raw::c_ushort,
    pub y1: ::std::os::raw::c_ushort,
    pub x2: ::std::os::raw::c_ushort,
    pub y2: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_drawable_info {
    pub num_rects: ::std::os::raw::c_uint,
    pub rects: *mut drm_clip_rect,
}
impl Default for drm_drawable_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_tex_region {
    pub next: ::std::os::raw::c_uchar,
    pub prev: ::std::os::raw::c_uchar,
    pub in_use: ::std::os::raw::c_uchar,
    pub padding: ::std::os::raw::c_uchar,
    pub age: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_hw_lock {
    #[doc = "< lock variable"]
    pub lock: ::std::os::raw::c_uint,
    #[doc = "< Pad to cache line"]
    pub padding: [::std::os::raw::c_char; 60usize],
}
impl Default for drm_hw_lock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_version {
    #[doc = "< Major version"]
    pub version_major: ::std::os::raw::c_int,
    #[doc = "< Minor version"]
    pub version_minor: ::std::os::raw::c_int,
    #[doc = "< Patch level"]
    pub version_patchlevel: ::std::os::raw::c_int,
    #[doc = "< Length of name buffer"]
    pub name_len: __kernel_size_t,
    #[doc = "< Name of driver"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Length of date buffer"]
    pub date_len: __kernel_size_t,
    #[doc = "< User-space buffer to hold date"]
    pub date: *mut ::std::os::raw::c_char,
    #[doc = "< Length of desc buffer"]
    pub desc_len: __kernel_size_t,
    #[doc = "< User-space buffer to hold desc"]
    pub desc: *mut ::std::os::raw::c_char,
}
impl Default for drm_version {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_unique {
    #[doc = "< Length of unique"]
    pub unique_len: __kernel_size_t,
    #[doc = "< Unique name for driver instantiation"]
    pub unique: *mut ::std::os::raw::c_char,
}
impl Default for drm_unique {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_list {
    #[doc = "< Length of user-space structures"]
    pub count: ::std::os::raw::c_int,
    pub version: *mut drm_version,
}
impl Default for drm_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_block {
    pub unused: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_control {
    pub func: drm_control__bindgen_ty_1,
    pub irq: ::std::os::raw::c_int,
}
pub const drm_control_DRM_ADD_COMMAND: drm_control__bindgen_ty_1 = 0;
pub const drm_control_DRM_RM_COMMAND: drm_control__bindgen_ty_1 = 1;
pub const drm_control_DRM_INST_HANDLER: drm_control__bindgen_ty_1 = 2;
pub const drm_control_DRM_UNINST_HANDLER: drm_control__bindgen_ty_1 = 3;
pub type drm_control__bindgen_ty_1 = ::std::os::raw::c_uint;
impl Default for drm_control {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< WC (no caching), no core dump"]
pub const drm_map_type__DRM_FRAME_BUFFER: drm_map_type = 0;
#[doc = "< no caching, no core dump"]
pub const drm_map_type__DRM_REGISTERS: drm_map_type = 1;
#[doc = "< shared, cached"]
pub const drm_map_type__DRM_SHM: drm_map_type = 2;
#[doc = "< AGP/GART"]
pub const drm_map_type__DRM_AGP: drm_map_type = 3;
#[doc = "< Scatter/gather memory for PCI DMA"]
pub const drm_map_type__DRM_SCATTER_GATHER: drm_map_type = 4;
#[doc = "< Consistent memory for PCI DMA"]
pub const drm_map_type__DRM_CONSISTENT: drm_map_type = 5;
pub type drm_map_type = ::std::os::raw::c_uint;
#[doc = "< Cannot be mapped to user-virtual"]
pub const drm_map_flags__DRM_RESTRICTED: drm_map_flags = 1;
pub const drm_map_flags__DRM_READ_ONLY: drm_map_flags = 2;
#[doc = "< shared, cached, locked"]
pub const drm_map_flags__DRM_LOCKED: drm_map_flags = 4;
#[doc = "< kernel requires access"]
pub const drm_map_flags__DRM_KERNEL: drm_map_flags = 8;
#[doc = "< use write-combining if available"]
pub const drm_map_flags__DRM_WRITE_COMBINING: drm_map_flags = 16;
#[doc = "< SHM page that contains lock"]
pub const drm_map_flags__DRM_CONTAINS_LOCK: drm_map_flags = 32;
#[doc = "< Removable mapping"]
pub const drm_map_flags__DRM_REMOVABLE: drm_map_flags = 64;
#[doc = "< Managed by driver"]
pub const drm_map_flags__DRM_DRIVER: drm_map_flags = 128;
pub type drm_map_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_ctx_priv_map {
    #[doc = "< Context requesting private mapping"]
    pub ctx_id: ::std::os::raw::c_uint,
    #[doc = "< Handle of map"]
    pub handle: *mut ::std::os::raw::c_void,
}
impl Default for drm_ctx_priv_map {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_map {
    #[doc = "< Requested physical address (0 for SAREA)"]
    pub offset: ::std::os::raw::c_ulong,
    #[doc = "< Requested physical size (bytes)"]
    pub size: ::std::os::raw::c_ulong,
    #[doc = "< Type of memory to map"]
    pub type_: drm_map_type,
    #[doc = "< Flags"]
    pub flags: drm_map_flags,
    #[doc = "< User-space: \"Handle\" to pass to mmap() */\n/**< Kernel-space: kernel-virtual address"]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = "< MTRR slot used"]
    pub mtrr: ::std::os::raw::c_int,
}
impl Default for drm_map {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_client {
    #[doc = "< Which client desired?"]
    pub idx: ::std::os::raw::c_int,
    #[doc = "< Is client authenticated?"]
    pub auth: ::std::os::raw::c_int,
    #[doc = "< Process ID"]
    pub pid: ::std::os::raw::c_ulong,
    #[doc = "< User ID"]
    pub uid: ::std::os::raw::c_ulong,
    #[doc = "< Magic"]
    pub magic: ::std::os::raw::c_ulong,
    #[doc = "< Ioctl count"]
    pub iocs: ::std::os::raw::c_ulong,
}
pub const drm_stat_type__DRM_STAT_LOCK: drm_stat_type = 0;
pub const drm_stat_type__DRM_STAT_OPENS: drm_stat_type = 1;
pub const drm_stat_type__DRM_STAT_CLOSES: drm_stat_type = 2;
pub const drm_stat_type__DRM_STAT_IOCTLS: drm_stat_type = 3;
pub const drm_stat_type__DRM_STAT_LOCKS: drm_stat_type = 4;
pub const drm_stat_type__DRM_STAT_UNLOCKS: drm_stat_type = 5;
#[doc = "< Generic value"]
pub const drm_stat_type__DRM_STAT_VALUE: drm_stat_type = 6;
#[doc = "< Generic byte counter (1024bytes/K)"]
pub const drm_stat_type__DRM_STAT_BYTE: drm_stat_type = 7;
#[doc = "< Generic non-byte counter (1000/k)"]
pub const drm_stat_type__DRM_STAT_COUNT: drm_stat_type = 8;
#[doc = "< IRQ"]
pub const drm_stat_type__DRM_STAT_IRQ: drm_stat_type = 9;
#[doc = "< Primary DMA bytes"]
pub const drm_stat_type__DRM_STAT_PRIMARY: drm_stat_type = 10;
#[doc = "< Secondary DMA bytes"]
pub const drm_stat_type__DRM_STAT_SECONDARY: drm_stat_type = 11;
#[doc = "< DMA"]
pub const drm_stat_type__DRM_STAT_DMA: drm_stat_type = 12;
#[doc = "< Special DMA (e.g., priority or polled)"]
pub const drm_stat_type__DRM_STAT_SPECIAL: drm_stat_type = 13;
#[doc = "< Missed DMA opportunity"]
pub const drm_stat_type__DRM_STAT_MISSED: drm_stat_type = 14;
pub type drm_stat_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_stats {
    pub count: ::std::os::raw::c_ulong,
    pub data: [drm_stats__bindgen_ty_1; 15usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_stats__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulong,
    pub type_: drm_stat_type,
}
impl Default for drm_stats__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for drm_stats {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Wait until hardware is ready for DMA"]
pub const drm_lock_flags__DRM_LOCK_READY: drm_lock_flags = 1;
#[doc = "< Wait until hardware quiescent"]
pub const drm_lock_flags__DRM_LOCK_QUIESCENT: drm_lock_flags = 2;
#[doc = "< Flush this context's DMA queue first"]
pub const drm_lock_flags__DRM_LOCK_FLUSH: drm_lock_flags = 4;
#[doc = "< Flush all DMA queues first"]
pub const drm_lock_flags__DRM_LOCK_FLUSH_ALL: drm_lock_flags = 8;
#[doc = "< Halt all current and future queues"]
pub const drm_lock_flags__DRM_HALT_ALL_QUEUES: drm_lock_flags = 16;
#[doc = "< Halt all current queues"]
pub const drm_lock_flags__DRM_HALT_CUR_QUEUES: drm_lock_flags = 32;
pub type drm_lock_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_lock {
    pub context: ::std::os::raw::c_int,
    pub flags: drm_lock_flags,
}
impl Default for drm_lock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "<\n Block until buffer dispatched.\n\n \\note The buffer may not yet have\n been processed by the hardware --\n getting a hardware lock with the\n hardware quiescent will ensure\n that the buffer has been\n processed."]
pub const drm_dma_flags__DRM_DMA_BLOCK: drm_dma_flags = 1;
#[doc = "< Dispatch while lock held"]
pub const drm_dma_flags__DRM_DMA_WHILE_LOCKED: drm_dma_flags = 2;
#[doc = "< High priority dispatch"]
pub const drm_dma_flags__DRM_DMA_PRIORITY: drm_dma_flags = 4;
#[doc = "< Wait for free buffers"]
pub const drm_dma_flags__DRM_DMA_WAIT: drm_dma_flags = 16;
#[doc = "< Smaller-than-requested buffers OK"]
pub const drm_dma_flags__DRM_DMA_SMALLER_OK: drm_dma_flags = 32;
#[doc = "< Larger-than-requested buffers OK"]
pub const drm_dma_flags__DRM_DMA_LARGER_OK: drm_dma_flags = 64;
pub type drm_dma_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_buf_desc {
    #[doc = "< Number of buffers of this size"]
    pub count: ::std::os::raw::c_int,
    #[doc = "< Size in bytes"]
    pub size: ::std::os::raw::c_int,
    #[doc = "< Low water mark"]
    pub low_mark: ::std::os::raw::c_int,
    #[doc = "< High water mark"]
    pub high_mark: ::std::os::raw::c_int,
    pub flags: drm_buf_desc__bindgen_ty_1,
    #[doc = "<\n Start address of where the AGP buffers are\n in the AGP aperture"]
    pub agp_start: ::std::os::raw::c_ulong,
}
#[doc = "< Align on page boundaries for DMA"]
pub const drm_buf_desc__DRM_PAGE_ALIGN: drm_buf_desc__bindgen_ty_1 = 1;
#[doc = "< Buffer is in AGP space"]
pub const drm_buf_desc__DRM_AGP_BUFFER: drm_buf_desc__bindgen_ty_1 = 2;
#[doc = "< Scatter/gather memory buffer"]
pub const drm_buf_desc__DRM_SG_BUFFER: drm_buf_desc__bindgen_ty_1 = 4;
#[doc = "< Buffer is in frame buffer"]
pub const drm_buf_desc__DRM_FB_BUFFER: drm_buf_desc__bindgen_ty_1 = 8;
#[doc = "< Map PCI DMA buffer read-only"]
pub const drm_buf_desc__DRM_PCI_BUFFER_RO: drm_buf_desc__bindgen_ty_1 = 16;
pub type drm_buf_desc__bindgen_ty_1 = ::std::os::raw::c_uint;
impl Default for drm_buf_desc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_buf_info {
    #[doc = "< Entries in list"]
    pub count: ::std::os::raw::c_int,
    pub list: *mut drm_buf_desc,
}
impl Default for drm_buf_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_buf_free {
    pub count: ::std::os::raw::c_int,
    pub list: *mut ::std::os::raw::c_int,
}
impl Default for drm_buf_free {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_buf_pub {
    #[doc = "< Index into the master buffer list"]
    pub idx: ::std::os::raw::c_int,
    #[doc = "< Buffer size"]
    pub total: ::std::os::raw::c_int,
    #[doc = "< Amount of buffer in use (for DMA)"]
    pub used: ::std::os::raw::c_int,
    #[doc = "< Address of buffer"]
    pub address: *mut ::std::os::raw::c_void,
}
impl Default for drm_buf_pub {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_buf_map {
    #[doc = "< Length of the buffer list"]
    pub count: ::std::os::raw::c_int,
    #[doc = "< Mmap'd area in user-virtual"]
    pub virtual_: *mut ::std::os::raw::c_void,
    #[doc = "< Buffer information"]
    pub list: *mut drm_buf_pub,
}
impl Default for drm_buf_map {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_dma {
    #[doc = "< Context handle"]
    pub context: ::std::os::raw::c_int,
    #[doc = "< Number of buffers to send"]
    pub send_count: ::std::os::raw::c_int,
    #[doc = "< List of handles to buffers"]
    pub send_indices: *mut ::std::os::raw::c_int,
    #[doc = "< Lengths of data to send"]
    pub send_sizes: *mut ::std::os::raw::c_int,
    #[doc = "< Flags"]
    pub flags: drm_dma_flags,
    #[doc = "< Number of buffers requested"]
    pub request_count: ::std::os::raw::c_int,
    #[doc = "< Desired size for buffers"]
    pub request_size: ::std::os::raw::c_int,
    #[doc = "< Buffer information"]
    pub request_indices: *mut ::std::os::raw::c_int,
    pub request_sizes: *mut ::std::os::raw::c_int,
    #[doc = "< Number of buffers granted"]
    pub granted_count: ::std::os::raw::c_int,
}
impl Default for drm_dma {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const drm_ctx_flags__DRM_CONTEXT_PRESERVED: drm_ctx_flags = 1;
pub const drm_ctx_flags__DRM_CONTEXT_2DONLY: drm_ctx_flags = 2;
pub type drm_ctx_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_ctx {
    pub handle: drm_context_t,
    pub flags: drm_ctx_flags,
}
impl Default for drm_ctx {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_ctx_res {
    pub count: ::std::os::raw::c_int,
    pub contexts: *mut drm_ctx,
}
impl Default for drm_ctx_res {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_draw {
    pub handle: drm_drawable_t,
}
pub const drm_drawable_info_type_t_DRM_DRAWABLE_CLIPRECTS: drm_drawable_info_type_t = 0;
pub type drm_drawable_info_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_update_draw {
    pub handle: drm_drawable_t,
    pub type_: ::std::os::raw::c_uint,
    pub num: ::std::os::raw::c_uint,
    pub data: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_auth {
    pub magic: drm_magic_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_irq_busid {
    #[doc = "< IRQ number"]
    pub irq: ::std::os::raw::c_int,
    #[doc = "< bus number"]
    pub busnum: ::std::os::raw::c_int,
    #[doc = "< device number"]
    pub devnum: ::std::os::raw::c_int,
    #[doc = "< function number"]
    pub funcnum: ::std::os::raw::c_int,
}
#[doc = "< Wait for specific vblank sequence number"]
pub const drm_vblank_seq_type__DRM_VBLANK_ABSOLUTE: drm_vblank_seq_type = 0;
#[doc = "< Wait for given number of vblanks"]
pub const drm_vblank_seq_type__DRM_VBLANK_RELATIVE: drm_vblank_seq_type = 1;
pub const drm_vblank_seq_type__DRM_VBLANK_HIGH_CRTC_MASK: drm_vblank_seq_type = 62;
#[doc = "< Send event instead of blocking"]
pub const drm_vblank_seq_type__DRM_VBLANK_EVENT: drm_vblank_seq_type = 67108864;
#[doc = "< Scheduled buffer swap should flip"]
pub const drm_vblank_seq_type__DRM_VBLANK_FLIP: drm_vblank_seq_type = 134217728;
#[doc = "< If missed, wait for next vblank"]
pub const drm_vblank_seq_type__DRM_VBLANK_NEXTONMISS: drm_vblank_seq_type = 268435456;
#[doc = "< Secondary display controller"]
pub const drm_vblank_seq_type__DRM_VBLANK_SECONDARY: drm_vblank_seq_type = 536870912;
#[doc = "< Send signal instead of blocking, unsupported"]
pub const drm_vblank_seq_type__DRM_VBLANK_SIGNAL: drm_vblank_seq_type = 1073741824;
pub type drm_vblank_seq_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_wait_vblank_request {
    pub type_: drm_vblank_seq_type,
    pub sequence: ::std::os::raw::c_uint,
    pub signal: ::std::os::raw::c_ulong,
}
impl Default for drm_wait_vblank_request {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drm_wait_vblank_reply {
    pub type_: drm_vblank_seq_type,
    pub sequence: ::std::os::raw::c_uint,
    pub tval_sec: ::std::os::raw::c_long,
    pub tval_usec: ::std::os::raw::c_long,
}
impl Default for drm_wait_vblank_reply {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union drm_wait_vblank {
    pub request: drm_wait_vblank_request,
    pub reply: drm_wait_vblank_reply,
}
impl Default for drm_wait_vblank {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_modeset_ctl {
    pub crtc: __u32,
    pub cmd: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_agp_mode {
    #[doc = "< AGP mode"]
    pub mode: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_agp_buffer {
    #[doc = "< In bytes -- will round to page boundary"]
    pub size: ::std::os::raw::c_ulong,
    #[doc = "< Used for binding / unbinding"]
    pub handle: ::std::os::raw::c_ulong,
    #[doc = "< Type of memory to allocate"]
    pub type_: ::std::os::raw::c_ulong,
    #[doc = "< Physical used by i810"]
    pub physical: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_agp_binding {
    #[doc = "< From drm_agp_buffer"]
    pub handle: ::std::os::raw::c_ulong,
    #[doc = "< In bytes -- will round to page boundary"]
    pub offset: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_agp_info {
    pub agp_version_major: ::std::os::raw::c_int,
    pub agp_version_minor: ::std::os::raw::c_int,
    pub mode: ::std::os::raw::c_ulong,
    pub aperture_base: ::std::os::raw::c_ulong,
    pub aperture_size: ::std::os::raw::c_ulong,
    pub memory_allowed: ::std::os::raw::c_ulong,
    pub memory_used: ::std::os::raw::c_ulong,
    pub id_vendor: ::std::os::raw::c_ushort,
    pub id_device: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_scatter_gather {
    #[doc = "< In bytes -- will round to page boundary"]
    pub size: ::std::os::raw::c_ulong,
    #[doc = "< Used for mapping / unmapping"]
    pub handle: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_set_version {
    pub drm_di_major: ::std::os::raw::c_int,
    pub drm_di_minor: ::std::os::raw::c_int,
    pub drm_dd_major: ::std::os::raw::c_int,
    pub drm_dd_minor: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_gem_close {
    #[doc = " Handle of the object to be closed."]
    pub handle: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_gem_flink {
    #[doc = " Handle for the object being named"]
    pub handle: __u32,
    #[doc = " Returned global name"]
    pub name: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_gem_open {
    #[doc = " Name of object being opened"]
    pub name: __u32,
    #[doc = " Returned handle for the object"]
    pub handle: __u32,
    #[doc = " Returned size of the object"]
    pub size: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_get_cap {
    pub capability: __u64,
    pub value: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_set_client_cap {
    pub capability: __u64,
    pub value: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_prime_handle {
    pub handle: __u32,
    #[doc = " Flags.. only applicable for handle->fd"]
    pub flags: __u32,
    #[doc = " Returned dmabuf file descriptor"]
    pub fd: __s32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_syncobj_create {
    pub handle: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_syncobj_destroy {
    pub handle: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_syncobj_handle {
    pub handle: __u32,
    pub flags: __u32,
    pub fd: __s32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_syncobj_transfer {
    pub src_handle: __u32,
    pub dst_handle: __u32,
    pub src_point: __u64,
    pub dst_point: __u64,
    pub flags: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_syncobj_wait {
    pub handles: __u64,
    pub timeout_nsec: __s64,
    pub count_handles: __u32,
    pub flags: __u32,
    pub first_signaled: __u32,
    pub pad: __u32,
    #[doc = " @deadline_nsec - fence deadline hint\n\n Deadline hint, in absolute CLOCK_MONOTONIC, to set on backing\n fence(s) if the DRM_SYNCOBJ_WAIT_FLAGS_WAIT_DEADLINE flag is\n set."]
    pub deadline_nsec: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_syncobj_timeline_wait {
    pub handles: __u64,
    pub points: __u64,
    pub timeout_nsec: __s64,
    pub count_handles: __u32,
    pub flags: __u32,
    pub first_signaled: __u32,
    pub pad: __u32,
    #[doc = " @deadline_nsec - fence deadline hint\n\n Deadline hint, in absolute CLOCK_MONOTONIC, to set on backing\n fence(s) if the DRM_SYNCOBJ_WAIT_FLAGS_WAIT_DEADLINE flag is\n set."]
    pub deadline_nsec: __u64,
}
#[doc = " struct drm_syncobj_eventfd\n @handle: syncobj handle.\n @flags: Zero to wait for the point to be signalled, or\n         &DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE to wait for a fence to be\n         available for the point.\n @point: syncobj timeline point (set to zero for binary syncobjs).\n @fd: Existing eventfd to sent events to.\n @pad: Must be zero.\n\n Register an eventfd to be signalled by a syncobj. The eventfd counter will\n be incremented by one."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_syncobj_eventfd {
    pub handle: __u32,
    pub flags: __u32,
    pub point: __u64,
    pub fd: __s32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_syncobj_array {
    pub handles: __u64,
    pub count_handles: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_syncobj_timeline_array {
    pub handles: __u64,
    pub points: __u64,
    pub count_handles: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_crtc_get_sequence {
    pub crtc_id: __u32,
    pub active: __u32,
    pub sequence: __u64,
    pub sequence_ns: __s64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_crtc_queue_sequence {
    pub crtc_id: __u32,
    pub flags: __u32,
    pub sequence: __u64,
    pub user_data: __u64,
}
#[doc = " struct drm_mode_modeinfo - Display mode information.\n @clock: pixel clock in kHz\n @hdisplay: horizontal display size\n @hsync_start: horizontal sync start\n @hsync_end: horizontal sync end\n @htotal: horizontal total size\n @hskew: horizontal skew\n @vdisplay: vertical display size\n @vsync_start: vertical sync start\n @vsync_end: vertical sync end\n @vtotal: vertical total size\n @vscan: vertical scan\n @vrefresh: approximate vertical refresh rate in Hz\n @flags: bitmask of misc. flags, see DRM_MODE_FLAG_* defines\n @type: bitmask of type flags, see DRM_MODE_TYPE_* defines\n @name: string describing the mode resolution\n\n This is the user-space API display mode information structure. For the\n kernel version see struct drm_display_mode."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_modeinfo {
    pub clock: __u32,
    pub hdisplay: __u16,
    pub hsync_start: __u16,
    pub hsync_end: __u16,
    pub htotal: __u16,
    pub hskew: __u16,
    pub vdisplay: __u16,
    pub vsync_start: __u16,
    pub vsync_end: __u16,
    pub vtotal: __u16,
    pub vscan: __u16,
    pub vrefresh: __u32,
    pub flags: __u32,
    pub type_: __u32,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_card_res {
    pub fb_id_ptr: __u64,
    pub crtc_id_ptr: __u64,
    pub connector_id_ptr: __u64,
    pub encoder_id_ptr: __u64,
    pub count_fbs: __u32,
    pub count_crtcs: __u32,
    pub count_connectors: __u32,
    pub count_encoders: __u32,
    pub min_width: __u32,
    pub max_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_crtc {
    pub set_connectors_ptr: __u64,
    pub count_connectors: __u32,
    #[doc = "< Id"]
    pub crtc_id: __u32,
    #[doc = "< Id of framebuffer"]
    pub fb_id: __u32,
    #[doc = "< x Position on the framebuffer"]
    pub x: __u32,
    #[doc = "< y Position on the framebuffer"]
    pub y: __u32,
    pub gamma_size: __u32,
    pub mode_valid: __u32,
    pub mode: drm_mode_modeinfo,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_set_plane {
    pub plane_id: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub crtc_x: __s32,
    pub crtc_y: __s32,
    pub crtc_w: __u32,
    pub crtc_h: __u32,
    pub src_x: __u32,
    pub src_y: __u32,
    pub src_h: __u32,
    pub src_w: __u32,
}
#[doc = " struct drm_mode_get_plane - Get plane metadata.\n\n Userspace can perform a GETPLANE ioctl to retrieve information about a\n plane.\n\n To retrieve the number of formats supported, set @count_format_types to zero\n and call the ioctl. @count_format_types will be updated with the value.\n\n To retrieve these formats, allocate an array with the memory needed to store\n @count_format_types formats. Point @format_type_ptr to this array and call\n the ioctl again (with @count_format_types still set to the value returned in\n the first ioctl call)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_get_plane {
    #[doc = " @plane_id: Object ID of the plane whose information should be\n retrieved. Set by caller."]
    pub plane_id: __u32,
    #[doc = " @crtc_id: Object ID of the current CRTC."]
    pub crtc_id: __u32,
    #[doc = " @fb_id: Object ID of the current fb."]
    pub fb_id: __u32,
    #[doc = " @possible_crtcs: Bitmask of CRTC's compatible with the plane. CRTC's\n are created and they receive an index, which corresponds to their\n position in the bitmask. Bit N corresponds to\n :ref:`CRTC index<crtc_index>` N."]
    pub possible_crtcs: __u32,
    #[doc = " @gamma_size: Never used."]
    pub gamma_size: __u32,
    #[doc = " @count_format_types: Number of formats."]
    pub count_format_types: __u32,
    #[doc = " @format_type_ptr: Pointer to ``__u32`` array of formats that are\n supported by the plane. These formats do not require modifiers."]
    pub format_type_ptr: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_get_plane_res {
    pub plane_id_ptr: __u64,
    pub count_planes: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_get_encoder {
    pub encoder_id: __u32,
    pub encoder_type: __u32,
    #[doc = "< Id of crtc"]
    pub crtc_id: __u32,
    pub possible_crtcs: __u32,
    pub possible_clones: __u32,
}
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Automatic: drm_mode_subconnector = 0;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Unknown: drm_mode_subconnector = 0;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_VGA: drm_mode_subconnector = 1;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_DVID: drm_mode_subconnector = 3;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_DVIA: drm_mode_subconnector = 4;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Composite: drm_mode_subconnector = 5;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_SVIDEO: drm_mode_subconnector = 6;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Component: drm_mode_subconnector = 8;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_SCART: drm_mode_subconnector = 9;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_DisplayPort: drm_mode_subconnector = 10;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_HDMIA: drm_mode_subconnector = 11;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Native: drm_mode_subconnector = 15;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Wireless: drm_mode_subconnector = 18;
pub type drm_mode_subconnector = ::std::os::raw::c_uint;
#[doc = " struct drm_mode_get_connector - Get connector metadata.\n\n User-space can perform a GETCONNECTOR ioctl to retrieve information about a\n connector. User-space is expected to retrieve encoders, modes and properties\n by performing this ioctl at least twice: the first time to retrieve the\n number of elements, the second time to retrieve the elements themselves.\n\n To retrieve the number of elements, set @count_props and @count_encoders to\n zero, set @count_modes to 1, and set @modes_ptr to a temporary struct\n drm_mode_modeinfo element.\n\n To retrieve the elements, allocate arrays for @encoders_ptr, @modes_ptr,\n @props_ptr and @prop_values_ptr, then set @count_modes, @count_props and\n @count_encoders to their capacity.\n\n Performing the ioctl only twice may be racy: the number of elements may have\n changed with a hotplug event in-between the two ioctls. User-space is\n expected to retry the last ioctl until the number of elements stabilizes.\n The kernel won't fill any array which doesn't have the expected length.\n\n **Force-probing a connector**\n\n If the @count_modes field is set to zero and the DRM client is the current\n DRM master, the kernel will perform a forced probe on the connector to\n refresh the connector status, modes and EDID. A forced-probe can be slow,\n might cause flickering and the ioctl will block.\n\n User-space needs to force-probe connectors to ensure their metadata is\n up-to-date at startup and after receiving a hot-plug event. User-space\n may perform a forced-probe when the user explicitly requests it. User-space\n shouldn't perform a forced-probe in other situations."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_get_connector {
    #[doc = " @encoders_ptr: Pointer to ``__u32`` array of object IDs."]
    pub encoders_ptr: __u64,
    #[doc = " @modes_ptr: Pointer to struct drm_mode_modeinfo array."]
    pub modes_ptr: __u64,
    #[doc = " @props_ptr: Pointer to ``__u32`` array of property IDs."]
    pub props_ptr: __u64,
    #[doc = " @prop_values_ptr: Pointer to ``__u64`` array of property values."]
    pub prop_values_ptr: __u64,
    #[doc = " @count_modes: Number of modes."]
    pub count_modes: __u32,
    #[doc = " @count_props: Number of properties."]
    pub count_props: __u32,
    #[doc = " @count_encoders: Number of encoders."]
    pub count_encoders: __u32,
    #[doc = " @encoder_id: Object ID of the current encoder."]
    pub encoder_id: __u32,
    #[doc = " @connector_id: Object ID of the connector."]
    pub connector_id: __u32,
    #[doc = " @connector_type: Type of the connector.\n\n See DRM_MODE_CONNECTOR_* defines."]
    pub connector_type: __u32,
    #[doc = " @connector_type_id: Type-specific connector number.\n\n This is not an object ID. This is a per-type connector number. Each\n (type, type_id) combination is unique across all connectors of a DRM\n device.\n\n The (type, type_id) combination is not a stable identifier: the\n type_id can change depending on the driver probe order."]
    pub connector_type_id: __u32,
    #[doc = " @connection: Status of the connector.\n\n See enum drm_connector_status."]
    pub connection: __u32,
    #[doc = " @mm_width: Width of the connected sink in millimeters."]
    pub mm_width: __u32,
    #[doc = " @mm_height: Height of the connected sink in millimeters."]
    pub mm_height: __u32,
    #[doc = " @subpixel: Subpixel order of the connected sink.\n\n See enum subpixel_order."]
    pub subpixel: __u32,
    #[doc = " @pad: Padding, must be zero."]
    pub pad: __u32,
}
#[doc = " struct drm_mode_property_enum - Description for an enum/bitfield entry.\n @value: numeric value for this enum entry.\n @name: symbolic name for this enum entry.\n\n See struct drm_property_enum for details."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_property_enum {
    pub value: __u64,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[doc = " struct drm_mode_get_property - Get property metadata.\n\n User-space can perform a GETPROPERTY ioctl to retrieve information about a\n property. The same property may be attached to multiple objects, see\n \"Modeset Base Object Abstraction\".\n\n The meaning of the @values_ptr field changes depending on the property type.\n See &drm_property.flags for more details.\n\n The @enum_blob_ptr and @count_enum_blobs fields are only meaningful when the\n property has the type &DRM_MODE_PROP_ENUM or &DRM_MODE_PROP_BITMASK. For\n backwards compatibility, the kernel will always set @count_enum_blobs to\n zero when the property has the type &DRM_MODE_PROP_BLOB. User-space must\n ignore these two fields if the property has a different type.\n\n User-space is expected to retrieve values and enums by performing this ioctl\n at least twice: the first time to retrieve the number of elements, the\n second time to retrieve the elements themselves.\n\n To retrieve the number of elements, set @count_values and @count_enum_blobs\n to zero, then call the ioctl. @count_values will be updated with the number\n of elements. If the property has the type &DRM_MODE_PROP_ENUM or\n &DRM_MODE_PROP_BITMASK, @count_enum_blobs will be updated as well.\n\n To retrieve the elements themselves, allocate an array for @values_ptr and\n set @count_values to its capacity. If the property has the type\n &DRM_MODE_PROP_ENUM or &DRM_MODE_PROP_BITMASK, allocate an array for\n @enum_blob_ptr and set @count_enum_blobs to its capacity. Calling the ioctl\n again will fill the arrays."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_get_property {
    #[doc = " @values_ptr: Pointer to a ``__u64`` array."]
    pub values_ptr: __u64,
    #[doc = " @enum_blob_ptr: Pointer to a struct drm_mode_property_enum array."]
    pub enum_blob_ptr: __u64,
    #[doc = " @prop_id: Object ID of the property which should be retrieved. Set\n by the caller."]
    pub prop_id: __u32,
    #[doc = " @flags: ``DRM_MODE_PROP_*`` bitfield. See &drm_property.flags for\n a definition of the flags."]
    pub flags: __u32,
    #[doc = " @name: Symbolic property name. User-space should use this field to\n recognize properties."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = " @count_values: Number of elements in @values_ptr."]
    pub count_values: __u32,
    #[doc = " @count_enum_blobs: Number of elements in @enum_blob_ptr."]
    pub count_enum_blobs: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_connector_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub connector_id: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_obj_get_properties {
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub count_props: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_obj_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_get_blob {
    pub blob_id: __u32,
    pub length: __u32,
    pub data: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_fb_cmd {
    pub fb_id: __u32,
    pub width: __u32,
    pub height: __u32,
    pub pitch: __u32,
    pub bpp: __u32,
    pub depth: __u32,
    pub handle: __u32,
}
#[doc = " struct drm_mode_fb_cmd2 - Frame-buffer metadata.\n\n This struct holds frame-buffer metadata. There are two ways to use it:\n\n - User-space can fill this struct and perform a &DRM_IOCTL_MODE_ADDFB2\n   ioctl to register a new frame-buffer. The new frame-buffer object ID will\n   be set by the kernel in @fb_id.\n - User-space can set @fb_id and perform a &DRM_IOCTL_MODE_GETFB2 ioctl to\n   fetch metadata about an existing frame-buffer.\n\n In case of planar formats, this struct allows up to 4 buffer objects with\n offsets and pitches per plane. The pitch and offset order are dictated by\n the format FourCC as defined by ``drm_fourcc.h``, e.g. NV12 is described as:\n\n     YUV 4:2:0 image with a plane of 8-bit Y samples followed by an\n     interleaved U/V plane containing 8-bit 2x2 subsampled colour difference\n     samples.\n\n So it would consist of a Y plane at ``offsets[0]`` and a UV plane at\n ``offsets[1]``.\n\n To accommodate tiled, compressed, etc formats, a modifier can be specified.\n For more information see the \"Format Modifiers\" section. Note that even\n though it looks like we have a modifier per-plane, we in fact do not. The\n modifier for each plane must be identical. Thus all combinations of\n different data layouts for multi-plane formats must be enumerated as\n separate modifiers.\n\n All of the entries in @handles, @pitches, @offsets and @modifier must be\n zero when unused. Warning, for @offsets and @modifier zero can't be used to\n figure out whether the entry is used or not since it's a valid value (a zero\n offset is common, and a zero modifier is &DRM_FORMAT_MOD_LINEAR)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_fb_cmd2 {
    #[doc = " @fb_id: Object ID of the frame-buffer."]
    pub fb_id: __u32,
    #[doc = " @width: Width of the frame-buffer."]
    pub width: __u32,
    #[doc = " @height: Height of the frame-buffer."]
    pub height: __u32,
    #[doc = " @pixel_format: FourCC format code, see ``DRM_FORMAT_*`` constants in\n ``drm_fourcc.h``."]
    pub pixel_format: __u32,
    #[doc = " @flags: Frame-buffer flags (see &DRM_MODE_FB_INTERLACED and\n &DRM_MODE_FB_MODIFIERS)."]
    pub flags: __u32,
    #[doc = " @handles: GEM buffer handle, one per plane. Set to 0 if the plane is\n unused. The same handle can be used for multiple planes."]
    pub handles: [__u32; 4usize],
    #[doc = " @pitches: Pitch (aka. stride) in bytes, one per plane."]
    pub pitches: [__u32; 4usize],
    #[doc = " @offsets: Offset into the buffer in bytes, one per plane."]
    pub offsets: [__u32; 4usize],
    #[doc = " @modifier: Format modifier, one per plane. See ``DRM_FORMAT_MOD_*``\n constants in ``drm_fourcc.h``. All planes must use the same\n modifier. Ignored unless &DRM_MODE_FB_MODIFIERS is set in @flags."]
    pub modifier: [__u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_fb_dirty_cmd {
    pub fb_id: __u32,
    pub flags: __u32,
    pub color: __u32,
    pub num_clips: __u32,
    pub clips_ptr: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_mode_cmd {
    pub connector_id: __u32,
    pub mode: drm_mode_modeinfo,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_cursor {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_cursor2 {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
    pub hot_x: __s32,
    pub hot_y: __s32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_crtc_lut {
    pub crtc_id: __u32,
    pub gamma_size: __u32,
    pub red: __u64,
    pub green: __u64,
    pub blue: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_color_ctm {
    pub matrix: [__u64; 9usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_color_ctm_3x4 {
    pub matrix: [__u64; 12usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_color_lut {
    pub red: __u16,
    pub green: __u16,
    pub blue: __u16,
    pub reserved: __u16,
}
#[doc = " struct hdr_metadata_infoframe - HDR Metadata Infoframe Data.\n\n HDR Metadata Infoframe as per CTA 861.G spec. This is expected\n to match exactly with the spec.\n\n Userspace is expected to pass the metadata information as per\n the format described in this structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct hdr_metadata_infoframe {
    #[doc = " @eotf: Electro-Optical Transfer Function (EOTF)\n used in the stream."]
    pub eotf: __u8,
    #[doc = " @metadata_type: Static_Metadata_Descriptor_ID."]
    pub metadata_type: __u8,
    pub display_primaries: [hdr_metadata_infoframe__bindgen_ty_1; 3usize],
    pub white_point: hdr_metadata_infoframe__bindgen_ty_2,
    #[doc = " @max_display_mastering_luminance: Max Mastering Display Luminance.\n This value is coded as an unsigned 16-bit value in units of 1 cd/m2,\n where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2."]
    pub max_display_mastering_luminance: __u16,
    #[doc = " @min_display_mastering_luminance: Min Mastering Display Luminance.\n This value is coded as an unsigned 16-bit value in units of\n 0.0001 cd/m2, where 0x0001 represents 0.0001 cd/m2 and 0xFFFF\n represents 6.5535 cd/m2."]
    pub min_display_mastering_luminance: __u16,
    #[doc = " @max_cll: Max Content Light Level.\n This value is coded as an unsigned 16-bit value in units of 1 cd/m2,\n where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2."]
    pub max_cll: __u16,
    #[doc = " @max_fall: Max Frame Average Light Level.\n This value is coded as an unsigned 16-bit value in units of 1 cd/m2,\n where 0x0001 represents 1 cd/m2 and 0xFFFF represents 65535 cd/m2."]
    pub max_fall: __u16,
}
#[doc = " @display_primaries: Color Primaries of the Data.\n These are coded as unsigned 16-bit values in units of\n 0.00002, where 0x0000 represents zero and 0xC350\n represents 1.0000.\n @display_primaries.x: X coordinate of color primary.\n @display_primaries.y: Y coordinate of color primary."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct hdr_metadata_infoframe__bindgen_ty_1 {
    pub x: __u16,
    pub y: __u16,
}
#[doc = " @white_point: White Point of Colorspace Data.\n These are coded as unsigned 16-bit values in units of\n 0.00002, where 0x0000 represents zero and 0xC350\n represents 1.0000.\n @white_point.x: X coordinate of whitepoint of color primary.\n @white_point.y: Y coordinate of whitepoint of color primary."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct hdr_metadata_infoframe__bindgen_ty_2 {
    pub x: __u16,
    pub y: __u16,
}
#[doc = " struct hdr_output_metadata - HDR output metadata\n\n Metadata Information to be passed from userspace"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hdr_output_metadata {
    #[doc = " @metadata_type: Static_Metadata_Descriptor_ID."]
    pub metadata_type: __u32,
    pub __bindgen_anon_1: hdr_output_metadata__bindgen_ty_1,
}
#[doc = " @hdmi_metadata_type1: HDR Metadata Infoframe."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hdr_output_metadata__bindgen_ty_1 {
    pub hdmi_metadata_type1: hdr_metadata_infoframe,
}
impl Default for hdr_output_metadata__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for hdr_output_metadata {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_crtc_page_flip {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub user_data: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_crtc_page_flip_target {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub sequence: __u32,
    pub user_data: __u64,
}
#[doc = " struct drm_mode_create_dumb - Create a KMS dumb buffer for scanout.\n @height: buffer height in pixels\n @width: buffer width in pixels\n @bpp: bits per pixel\n @flags: must be zero\n @handle: buffer object handle\n @pitch: number of bytes between two consecutive lines\n @size: size of the whole buffer in bytes\n\n User-space fills @height, @width, @bpp and @flags. If the IOCTL succeeds,\n the kernel fills @handle, @pitch and @size."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_create_dumb {
    pub height: __u32,
    pub width: __u32,
    pub bpp: __u32,
    pub flags: __u32,
    pub handle: __u32,
    pub pitch: __u32,
    pub size: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_map_dumb {
    #[doc = " Handle for the object being mapped."]
    pub handle: __u32,
    pub pad: __u32,
    #[doc = " Fake offset to use for subsequent mmap call\n\n This is a fixed-size type for 32/64 compatibility."]
    pub offset: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_destroy_dumb {
    pub handle: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_atomic {
    pub flags: __u32,
    pub count_objs: __u32,
    pub objs_ptr: __u64,
    pub count_props_ptr: __u64,
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub reserved: __u64,
    pub user_data: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_format_modifier_blob {
    pub version: __u32,
    pub flags: __u32,
    pub count_formats: __u32,
    pub formats_offset: __u32,
    pub count_modifiers: __u32,
    pub modifiers_offset: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_format_modifier {
    pub formats: __u64,
    pub offset: __u32,
    pub pad: __u32,
    pub modifier: __u64,
}
#[doc = " struct drm_mode_create_blob - Create New blob property\n\n Create a new 'blob' data property, copying length bytes from data pointer,\n and returning new blob ID."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_create_blob {
    #[doc = " @data: Pointer to data to copy."]
    pub data: __u64,
    #[doc = " @length: Length of data to copy."]
    pub length: __u32,
    #[doc = " @blob_id: Return: new property ID."]
    pub blob_id: __u32,
}
#[doc = " struct drm_mode_destroy_blob - Destroy user blob\n @blob_id: blob_id to destroy\n\n Destroy a user-created blob property.\n\n User-space can release blobs as soon as they do not need to refer to them by\n their blob object ID.  For instance, if you are using a MODE_ID blob in an\n atomic commit and you will not make another commit re-using the same ID, you\n can destroy the blob as soon as the commit has been issued, without waiting\n for it to complete."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_destroy_blob {
    pub blob_id: __u32,
}
#[doc = " struct drm_mode_create_lease - Create lease\n\n Lease mode resources, creating another drm_master.\n\n The @object_ids array must reference at least one CRTC, one connector and\n one plane if &DRM_CLIENT_CAP_UNIVERSAL_PLANES is enabled. Alternatively,\n the lease can be completely empty."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_create_lease {
    #[doc = " @object_ids: Pointer to array of object ids (__u32)"]
    pub object_ids: __u64,
    #[doc = " @object_count: Number of object ids"]
    pub object_count: __u32,
    #[doc = " @flags: flags for new FD (O_CLOEXEC, etc)"]
    pub flags: __u32,
    #[doc = " @lessee_id: Return: unique identifier for lessee."]
    pub lessee_id: __u32,
    #[doc = " @fd: Return: file descriptor to new drm_master file"]
    pub fd: __u32,
}
#[doc = " struct drm_mode_list_lessees - List lessees\n\n List lesses from a drm_master."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_list_lessees {
    #[doc = " @count_lessees: Number of lessees.\n\n On input, provides length of the array.\n On output, provides total number. No\n more than the input number will be written\n back, so two calls can be used to get\n the size and then the data."]
    pub count_lessees: __u32,
    #[doc = " @pad: Padding."]
    pub pad: __u32,
    #[doc = " @lessees_ptr: Pointer to lessees.\n\n Pointer to __u64 array of lessee ids"]
    pub lessees_ptr: __u64,
}
#[doc = " struct drm_mode_get_lease - Get Lease\n\n Get leased objects."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_get_lease {
    #[doc = " @count_objects: Number of leased objects.\n\n On input, provides length of the array.\n On output, provides total number. No\n more than the input number will be written\n back, so two calls can be used to get\n the size and then the data."]
    pub count_objects: __u32,
    #[doc = " @pad: Padding."]
    pub pad: __u32,
    #[doc = " @objects_ptr: Pointer to objects.\n\n Pointer to __u32 array of object ids."]
    pub objects_ptr: __u64,
}
#[doc = " struct drm_mode_revoke_lease - Revoke lease"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_revoke_lease {
    #[doc = " @lessee_id: Unique ID of lessee"]
    pub lessee_id: __u32,
}
#[doc = " struct drm_mode_rect - Two dimensional rectangle.\n @x1: Horizontal starting coordinate (inclusive).\n @y1: Vertical starting coordinate (inclusive).\n @x2: Horizontal ending coordinate (exclusive).\n @y2: Vertical ending coordinate (exclusive).\n\n With drm subsystem using struct drm_rect to manage rectangular area this\n export it to user-space.\n\n Currently used by drm_mode_atomic blob property FB_DAMAGE_CLIPS."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_rect {
    pub x1: __s32,
    pub y1: __s32,
    pub x2: __s32,
    pub y2: __s32,
}
#[doc = " struct drm_mode_closefb\n @fb_id: Framebuffer ID.\n @pad: Must be zero."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_mode_closefb {
    pub fb_id: __u32,
    pub pad: __u32,
}
#[doc = " struct drm_event - Header for DRM events\n @type: event type.\n @length: total number of payload bytes (including header).\n\n This struct is a header for events written back to user-space on the DRM FD.\n A read on the DRM FD will always only return complete events: e.g. if the\n read buffer is 100 bytes large and there are two 64 byte events pending,\n only one will be returned.\n\n Event types 0 - 0x7fffffff are generic DRM events, 0x80000000 and\n up are chipset specific. Generic DRM events include &DRM_EVENT_VBLANK,\n &DRM_EVENT_FLIP_COMPLETE and &DRM_EVENT_CRTC_SEQUENCE."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_event {
    pub type_: __u32,
    pub length: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_event_vblank {
    pub base: drm_event,
    pub user_data: __u64,
    pub tv_sec: __u32,
    pub tv_usec: __u32,
    pub sequence: __u32,
    pub crtc_id: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_event_crtc_sequence {
    pub base: drm_event,
    pub user_data: __u64,
    pub time_ns: __s64,
    pub sequence: __u64,
}
pub type drm_clip_rect_t = drm_clip_rect;
pub type drm_drawable_info_t = drm_drawable_info;
pub type drm_tex_region_t = drm_tex_region;
pub type drm_hw_lock_t = drm_hw_lock;
pub type drm_version_t = drm_version;
pub type drm_unique_t = drm_unique;
pub type drm_list_t = drm_list;
pub type drm_block_t = drm_block;
pub type drm_control_t = drm_control;
pub use self::drm_map_flags as drm_map_flags_t;
pub use self::drm_map_type as drm_map_type_t;
pub type drm_ctx_priv_map_t = drm_ctx_priv_map;
pub type drm_map_t = drm_map;
pub type drm_client_t = drm_client;
pub use self::drm_stat_type as drm_stat_type_t;
pub type drm_stats_t = drm_stats;
pub use self::drm_lock_flags as drm_lock_flags_t;
pub type drm_lock_t = drm_lock;
pub use self::drm_dma_flags as drm_dma_flags_t;
pub type drm_buf_desc_t = drm_buf_desc;
pub type drm_buf_info_t = drm_buf_info;
pub type drm_buf_free_t = drm_buf_free;
pub type drm_buf_pub_t = drm_buf_pub;
pub type drm_buf_map_t = drm_buf_map;
pub type drm_dma_t = drm_dma;
pub type drm_wait_vblank_t = drm_wait_vblank;
pub type drm_agp_mode_t = drm_agp_mode;
pub use self::drm_ctx_flags as drm_ctx_flags_t;
pub type drm_ctx_t = drm_ctx;
pub type drm_ctx_res_t = drm_ctx_res;
pub type drm_draw_t = drm_draw;
pub type drm_update_draw_t = drm_update_draw;
pub type drm_auth_t = drm_auth;
pub type drm_irq_busid_t = drm_irq_busid;
pub use self::drm_vblank_seq_type as drm_vblank_seq_type_t;
pub type drm_agp_buffer_t = drm_agp_buffer;
pub type drm_agp_binding_t = drm_agp_binding;
pub type drm_agp_info_t = drm_agp_info;
pub type drm_scatter_gather_t = drm_scatter_gather;
pub type drm_set_version_t = drm_set_version;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_map {
    pub offset: __u64,
    pub handle: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_execbuffer_syncobj {
    pub handle: __u32,
    pub flags: __u32,
    pub point: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_execbuffer {
    pub flags: __u32,
    pub size: __u32,
    pub command: __u64,
    pub bo_handles: __u64,
    pub num_bo_handles: __u32,
    pub fence_fd: __s32,
    pub ring_idx: __u32,
    pub syncobj_stride: __u32,
    pub num_in_syncobjs: __u32,
    pub num_out_syncobjs: __u32,
    pub in_syncobjs: __u64,
    pub out_syncobjs: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_getparam {
    pub param: __u64,
    pub value: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_resource_create {
    pub target: __u32,
    pub format: __u32,
    pub bind: __u32,
    pub width: __u32,
    pub height: __u32,
    pub depth: __u32,
    pub array_size: __u32,
    pub last_level: __u32,
    pub nr_samples: __u32,
    pub flags: __u32,
    pub bo_handle: __u32,
    pub res_handle: __u32,
    pub size: __u32,
    pub stride: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_resource_info {
    pub bo_handle: __u32,
    pub res_handle: __u32,
    pub size: __u32,
    pub blob_mem: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_3d_box {
    pub x: __u32,
    pub y: __u32,
    pub z: __u32,
    pub w: __u32,
    pub h: __u32,
    pub d: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_3d_transfer_to_host {
    pub bo_handle: __u32,
    pub box_: drm_virtgpu_3d_box,
    pub level: __u32,
    pub offset: __u32,
    pub stride: __u32,
    pub layer_stride: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_3d_transfer_from_host {
    pub bo_handle: __u32,
    pub box_: drm_virtgpu_3d_box,
    pub level: __u32,
    pub offset: __u32,
    pub stride: __u32,
    pub layer_stride: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_3d_wait {
    pub handle: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_get_caps {
    pub cap_set_id: __u32,
    pub cap_set_ver: __u32,
    pub addr: __u64,
    pub size: __u32,
    pub pad: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_resource_create_blob {
    pub blob_mem: __u32,
    pub blob_flags: __u32,
    pub bo_handle: __u32,
    pub res_handle: __u32,
    pub size: __u64,
    pub pad: __u32,
    pub cmd_size: __u32,
    pub cmd: __u64,
    pub blob_id: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_context_set_param {
    pub param: __u64,
    pub value: __u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drm_virtgpu_context_init {
    pub num_params: __u32,
    pub pad: __u32,
    pub ctx_set_params: __u64,
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CrossDomainCapabilities {
    pub version: u32,
    pub supported_channels: u32,
    pub supports_dmabuf: u32,
    pub supports_external_gpu_memory: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CrossDomainImageRequirements {
    pub strides: [u32; 4usize],
    pub offsets: [u32; 4usize],
    pub modifier: u64,
    pub size: u64,
    pub blob_id: u32,
    pub map_info: u32,
    pub memory_idx: i32,
    pub physical_device_idx: i32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CrossDomainHeader {
    pub cmd: u8,
    pub fence_ctx_idx: u8,
    pub cmd_size: u16,
    pub pad: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CrossDomainInit {
    pub hdr: CrossDomainHeader,
    pub query_ring_id: u32,
    pub channel_ring_id: u32,
    pub channel_type: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CrossDomainGetImageRequirements {
    pub hdr: CrossDomainHeader,
    pub width: u32,
    pub height: u32,
    pub drm_format: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CrossDomainPoll {
    pub hdr: CrossDomainHeader,
    pub pad: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CrossDomainSendReceive {
    pub hdr: CrossDomainHeader,
    pub num_identifiers: u32,
    pub opaque_data_size: u32,
    pub identifiers: [u32; 28usize],
    pub identifier_types: [u32; 28usize],
    pub identifier_sizes: [u32; 28usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CrossDomainReadWrite {
    pub hdr: CrossDomainHeader,
    pub identifier: u32,
    pub hang_up: u32,
    pub opaque_data_size: u32,
    pub pad: u32,
}
